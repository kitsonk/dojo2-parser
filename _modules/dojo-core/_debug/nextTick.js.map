{"version":3,"file":"nextTick.js","sourceRoot":"","sources":["nextTick.ts"],"names":["createMacroScheduler","CallbackQueue","CallbackQueue.constructor","CallbackQueue.add","CallbackQueue.drain"],"mappings":"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","sourcesContent":["import has from './has';\nimport { Handle } from './interfaces';\nimport { QueueItem } from './queue';\n\n/**\n * Create macro-scheduler based nextTick function.\n */\nfunction createMacroScheduler(\n\tschedule: ((callback: () => void, timeout?: number) => void),\n\tclearSchedule: ((handle: any) => void)\n) {\n\tlet queue = new CallbackQueue();\n\tlet timer: any;\n\n\treturn function(callback: () => void): Handle {\n\t\tlet handle = queue.add(callback);\n\n\t\tif (!timer) {\n\t\t\ttimer = schedule(function (): void {\n\t\t\t\tclearSchedule(timer);\n\t\t\t\ttimer = null;\n\t\t\t\tqueue.drain();\n\t\t\t}, 0);\n\t\t}\n\n\t\treturn handle;\n\t};\n}\n\n/**\n * A queue of callbacks that will be executed in FIFO order when the queue is drained.\n */\nclass CallbackQueue {\n\tprivate _callbacks: QueueItem[] = [];\n\n\tadd(callback: () => void): { destroy: () => void } {\n\t\tlet _callback = {\n\t\t\tisActive: true,\n\t\t\tcallback: callback\n\t\t};\n\n\t\tthis._callbacks.push(_callback);\n\t\tcallback = null;\n\n\t\treturn {\n\t\t\tdestroy: function() {\n\t\t\t\tthis.destroy = function() {};\n\t\t\t\t_callback.isActive = false;\n\t\t\t\t_callback = null;\n\t\t\t}\n\t\t};\n\t}\n\n\tdrain(...args: any[]): void {\n\t\tlet callbacks = this._callbacks;\n\t\tlet item: QueueItem;\n\t\tlet count = callbacks.length;\n\n\t\t// Any callbacks added after drain is called will be processed\n\t\t// the next time drain is called\n\t\tthis._callbacks = [];\n\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\titem = callbacks[i];\n\t\t\tif (item && item.isActive) {\n\t\t\t\titem.callback.apply(null, args);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlet nextTick: (callback: () => void) => Handle;\nlet nodeVersion = has('host-node');\n\nif (nodeVersion) {\n\t// In Node.JS 0.9.x and 0.10.x, deeply recursive process.nextTick calls can cause stack overflows, so use\n\t// setImmediate.\n\tif (nodeVersion.indexOf('0.9.') === 0 || nodeVersion.indexOf('0.10.') === 0) {\n\t\tnextTick = createMacroScheduler(setImmediate, clearImmediate);\n\t}\n\telse {\n\t\tnextTick = function(callback: () => void): Handle {\n\t\t\tlet removed = false;\n\t\t\tprocess.nextTick(function (): void {\n\t\t\t\t// There isn't an API to remove a pending call from `process.nextTick`\n\t\t\t\tif (removed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcallback();\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tdestroy: function (): void {\n\t\t\t\t\tthis.destroy = () => {};\n\t\t\t\t\tremoved = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n}\nelse if (has('dom-mutationobserver')) {\n\tlet queue = new CallbackQueue();\n\n\tnextTick = (function (): typeof nextTick {\n\t\tlet MutationObserver = this.MutationObserver || this.WebKitMutationObserver;\n\t\tlet element = document.createElement('div');\n\t\tlet observer = new MutationObserver(function (): void {\n\t\t\tqueue.drain();\n\t\t});\n\n\t\tobserver.observe(element, { attributes: true });\n\n\t\treturn function(callback: () => void): Handle {\n\t\t\tlet handle = queue.add(callback);\n\t\t\telement.setAttribute('drainQueue', '1');\n\t\t\treturn handle;\n\t\t};\n\t})();\n}\nelse {\n\t// If nothing better is available, fallback to setTimeout\n\tnextTick = createMacroScheduler(setTimeout, clearTimeout);\n}\n\nexport default nextTick;\n"]}