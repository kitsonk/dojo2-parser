{"version":3,"file":"object.js","sourceRoot":"","sources":["object.ts"],"names":["assign","is"],"mappings":";;;;;;;;IAIA,AAJA;;;OAGG;oBACoB,MAAW;QAAEA,iBAAiBA;aAAjBA,WAAiBA,CAAjBA,sBAAiBA,CAAjBA,IAAiBA;YAAjBA,gCAAiBA;;QACpDA,EAAEA,CAACA,CAACA,MAAMA,IAAIA,IAAIA,CAACA,CAACA,CAACA;YACpBA,MAAMA,IAAIA,SAASA,CAACA,yCAAyCA,CAACA,CAACA;QAChEA,CAACA;QAEDA,MAAMA,GAAGA,MAAMA,CAACA,MAAMA,CAACA,CAACA;QAExBA,GAAGA,CAACA,CAACA,GAAGA,CAACA,CAACA,GAAGA,CAACA,EAAEA,QAAMA,GAAGA,OAAOA,CAACA,MAAMA,EAAEA,MAAMA,SAAKA,EAAEA,CAACA,GAAGA,QAAMA,EAAEA,CAACA,EAAEA,EAAEA,CAACA;YACvEA,MAAMA,GAAGA,OAAOA,CAACA,CAACA,CAACA,CAACA;YAEpBA,EAAEA,CAACA,CAACA,MAAMA,CAACA,CAACA,CAACA;gBACZA,MAAMA,GAAGA,MAAMA,CAACA,MAAMA,CAACA,CAACA;gBACxBA,IAAMA,IAAIA,GAAGA,MAAMA,CAACA,IAAIA,CAACA,MAAMA,CAACA,CAACA;gBAEjCA,GAAGA,CAACA,CAACA,GAAGA,CAACA,CAACA,GAAGA,CAACA,EAAEA,UAAUA,GAAGA,IAAIA,CAACA,MAAMA,EAAEA,GAAGA,SAAQA,EAAEA,CAACA,GAAGA,UAAUA,EAAEA,CAACA,EAAEA,EAAEA,CAACA;oBAC5EA,GAAGA,GAAGA,IAAIA,CAACA,CAACA,CAACA,CAACA;oBACdA,MAAMA,CAACA,GAAGA,CAACA,GAAGA,MAAMA,CAACA,GAAGA,CAACA,CAACA;gBAC3BA,CAACA;YACFA,CAACA;QACFA,CAACA;QACDA,MAAMA,CAACA,MAAMA,CAACA;IACfA,CAACA;IArBe,cAAM,SAqBrB,CAAA;IAMD,AAJA;;;OAGG;gBACgB,MAAW,EAAE,MAAW;QAC1CC,EAAEA,CAACA,CAACA,MAAMA,KAAKA,MAAMA,CAACA,CAACA,CAACA;YACvBA,MAAMA,CAACA,MAAMA,KAAKA,CAACA,IAAIA,CAACA,GAAGA,MAAMA,KAAKA,CAACA,GAAGA,MAAMA,EAAEA,KAAKA;YAANA,JAClDA,CAACA;QACDA,MAAMA,CAACA,MAAMA,KAAKA,MAAMA,IAAIA,MAAMA,KAAKA,MAAMA,EAAEA,MAAMA;QAAPA,JAC/CA,CAACA;IALe,UAAE,KAKjB,CAAA","sourcesContent":["/**\n * Copies the values of all enumerable own properties of one or more source objects to the target object.\n * @return The modified target object\n */\nexport function assign(target: any, ...sources: any[]): any {\n\tif (target == null) {\n\t\tthrow new TypeError('Cannot convert first argument to object');\n\t}\n\n\ttarget = Object(target);\n\n\tfor (let i = 0, length = sources.length, source: any; i < length; i++) {\n\t\tsource = sources[i];\n\n\t\tif (source) {\n\t\t\tsource = Object(source);\n\t\t\tconst keys = Object.keys(source);\n\n\t\t\tfor (let j = 0, keysLength = keys.length, key: string; j < keysLength; j++) {\n\t\t\t\tkey = keys[j];\n\t\t\t\ttarget[key] = source[key];\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * Determines whether two values are the same value.\n * @return true if the values are the same; false otherwise\n */\nexport function is(value1: any, value2: any): boolean {\n\tif (value1 === value2) {\n\t\treturn value1 !== 0 || 1 / value1 === 1 / value2; // -0\n\t}\n\treturn value1 !== value1 && value2 !== value2; // NaN\n}\n"]}